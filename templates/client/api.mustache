{{>partial_header}}
package {{packageName}}

{{#operations}}
import (
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
  models "github.com/coinbase/rosetta-sdk-go/models"
{{#imports}}	"{{import}}"
{{/imports}}
)

// Linger please
var (
	_ _context.Context
)

// {{classname}}Service {{classname}} service
type {{classname}}Service service
{{#operation}}

// {{operationId}}{{#notes}} {{notes}}{{/notes}}
func (a *{{{classname}}}Service) {{{nickname}}}(ctx _context.Context{{#hasParams}}, {{/hasParams}}{{#allParams}}{{#required}}{{paramName}} models.{{{dataType}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}localVarOptionals *{{#structPrefix}}{{&classname}}{{/structPrefix}}{{{nickname}}}Opts{{/hasOptionalParams}}) ({{#returnType}}*models.{{{returnType}}}, {{/returnType}} *models.Error, error) {
	var (
		localVarPostBody     interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "{{{path}}}"
	localVarHeaderParams := make(map[string]string)

	// to determine the Content-Type header
{{=<% %>=}}
	localVarHTTPContentTypes := []string{<%#consumes%>"<%&mediaType%>"<%^-last%>, <%/-last%><%/consumes%>}
<%={{ }}=%>

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
{{=<% %>=}}
	localVarHTTPHeaderAccepts := []string{<%#produces%>"<%&mediaType%>"<%^-last%>, <%/-last%><%/produces%>}
<%={{ }}=%>

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
{{#hasHeaderParams}}
{{#headerParams}}
	{{#required}}
	localVarHeaderParams["{{baseName}}"] = parameterToString({{paramName}}, "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}")
	{{/required}}
	{{^required}}
	if localVarOptionals != nil && localVarOptionals.{{vendorExtensions.x-export-param-name}}.IsSet() {
		localVarHeaderParams["{{baseName}}"] = parameterToString(localVarOptionals.{{vendorExtensions.x-export-param-name}}.Value(), "{{#collectionFormat}}{{collectionFormat}}{{/collectionFormat}}")
	}
	{{/required}}
{{/headerParams}}
{{/hasHeaderParams}}
{{#hasBodyParam}}
{{#bodyParams}}
  // body params
	localVarPostBody = &{{paramName}}
{{/bodyParams}}
{{/hasBodyParam}}

	r, err := a.client.prepareRequest(ctx, localVarPath, localVarPostBody, localVarHeaderParams)
	if err != nil {
    return nil, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(ctx, r)
	if err != nil || localVarHTTPResponse == nil {
    return nil, nil, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	defer localVarHTTPResponse.Body.Close()
	if err != nil {
    return nil, nil, err 
	}

	if localVarHTTPResponse.StatusCode != _nethttp.StatusOK {
    var v models.Error
    err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
    if err != nil {
      return nil, nil, err 
    }

		return nil, &v, fmt.Errorf("%+v", v) 
	}

	{{#returnType}}
  var v models.{{{returnType}}}
	err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		return nil, nil, err
	}

	{{/returnType}}
	return &v, nil, nil
}
{{/operation}}
{{/operations}}
